# (Under Construction) Cloud Layer

This repository corresponds to the cloud layer and is used to deploy projects. This layer is responsible to deploy a specific project, using the [Cloud Input Vars](#cloud-input-vars) as the input values that contain the data needed to [deploy the project](#deploying-a-project).

_It's recommended to use a controller layer, like defined at http://github.com/lucasbasquerotto/ctl, to manage projects and generate those variables, instead of using this layer to deploy a project directly._

## Demo

Before start using this layer, it's easier to see it in action. Below is a simple demo used to deploy a project. The demo uses pre-defined [input variables](#cloud-input-vars), and then execute this layer to deploy a project.

To execute the demo you will need a container engine (like `docker` or `podman`).

1. Create an empty directory somewhere in your filesystem, let's say, `/var/demo`.

2. Create 2 directories in it: `env` and `data` (the names could be different, just remember to use these directories when mapping volumes to the container).

3. Create a `demo.yml` file inside `env` with the data needed to deploy the project:

```yaml
# Enter the data here (see the demo examples)
```

4. Deploy the project:

```shell
docker run -it --rm -v /var/demo/env:/env -v /var/demo/data:/lrd local/demo
```

**The above commands in a shell script:**

```shell
mkdir -p /var/demo/env /var/demo/data

cat <<'SHELL' > /var/demo/env/demo.yml
# Enter the data here (see the demo examples)
SHELL

docker run -it --rm -v /var/demo/env:/env -v /var/demo/data:/lrd local/demo
```

**That's it. The project was deployed.**

🚀 You can see examples of project deployment demos [here](#TODO).

The demos are great for what they are meant to be: demos, prototypes. **They shouldn't be used for development** (bad DX if you need real time changes without having to push and pull newer versions of repositories, furthermore you are unable to clone repositories in specific locations defined by you in the project folder). **They also shouldn't be used in production environments** due to bad security (the vault value used for decryption is `123456`, and changes to the [project environment repository](#project-environment) may be lost if you forget to push them).

# Deploying a Project

The deployment of a project in this layer is done, by default, in 3 steps.

1. [Cloud Preparation Step](#cloud-preparation-step)

2. [Cloud Context Preparation Step](#cloud-context-preparation-step)

3. [Cloud Context Main Step](#cloud-context-main-step)

## Project Base Directory

The project base directory is the directory (`project_base_dir`) in which the files generated by the project deployment and used to deploy the project are located. The `project_base_dir` should be in the path `<base_path>/projects/<project_name>/` where `<base_path>` is a base folder for the relative paths of repositories defined in `path_params` (used in development).

When running with the `dev` [input variable](#cloud-input-vars) equal `true`, there should be a relative symlink `<project_base_dir>/dev/link` that points to `<base_path>` to map repositories (so that you can share repositories across projects).

When running this step in a container, `<project_base_dir>/dev` should map to `<base_path>` in the host, and a symlink `<base_path>/link` should be created pointing to itself (`.`) so that the relative symlinks work both inside and outside the container.

_If using the controller layer at http://github.com/lucasbasquerotto/ctl to deploy the project, the project base directory will be at `<root_dir>/projects/<project_name>/` and the symlinks and volume mappings will be already handled._

## Cloud Input Vars

The [Cloud Preparation Step](#cloud-preparation-step) needs a file in the following format located at `<project_base_dir>/files/ctl/vars.yml` to deploy a project:

```yaml
ctxs: []
dev: 'true'
env_params:
  env_dir: common
init:
  allow_container_type: false
  container: lucasbasquerotto/cloud:1.4.9
  container_type: docker
  root: true
  run_file: /usr/local/bin/run
key: demo
lax: true
migration: ''
path_params:
  path_env: repos/env
project_dir_relpath: projects/demo
repo:
  env_file: common/demo.yml
  src: https://github.com/lucasbasquerotto/env-base.git
  ssh_file: ''
  version: master
repo_vault:
  file: ''
  force: false
```

_(The values above are the output after running `./run launch --dev demo` with the `vars.yml` in the main environment repository being the same as [this example](http://github.com/lucasbasquerotto/ctl#main-environment-vars-file---example).)_

| Option | Description |
| ------ | ----------- |
| <nobr>`ctxs`</nobr> | Array with the contexts defined for the project. |
| <nobr>`dev`</nobr> | Boolean (or string equivalent) to specify if the project will run in development mode. |
| <nobr>`env_params`</nobr> | Object with the parameters specified in the `vars.yml` file in the [main environment repository](http://github.com/lucasbasquerotto/ctl#main-environment-repository). The parameters used will depend on the project and can be accessed in the [project environment file](#project-environment-file). |
| <nobr>`init.allow_container_type`</nobr> | Boolean (or string equivalent) to specify if the container engine that will deploy the project is to be allowed even if it's not one of the supported engines (docker and podman). |
| <nobr>`init.container`</nobr> | The container image that will deploy the project. |
| <nobr>`init.container_type`</nobr> | The container engine that will run the container that will deploy the project. |
| <nobr>`init.root`</nobr> | Boolean (or string equivalent) to specify if the container should be run as root. |
| <nobr>`init.run_file`</nobr> | Path to the file inside the container that will serve as an entrypoint to deploy the project. |
| <nobr>`key`</nobr> | Unique identifier of the project. |
| <nobr>`lax`</nobr> | Indicates if files and directories created and copied during the deployment will have less strict permissions (when `true`, recommended when in development). |
| <nobr>`migration`</nobr> | This will set the `migration` variable to be used to compare with the `migration` variable defined in the [project environment file](#project-environment-file), throwing an error in the preparation step, when the later value is defined and is different than the first `migration` variable. |
| <nobr>`path_params.path_env`</nobr> | When specified, is the directory, relative to the project root directory, in which the [project environment repository](#project-environment-repository) will cloned when in development mode. |
| <nobr>`path_params.path_env_base`</nobr> | When specified, is the directory, relative to the project root directory, in which the [project environment base repository](#project-environment-base-file) will cloned when in development mode. |
| <nobr>`path_params.path_map_repos`</nobr> | Dictionary of directories in which each key represents a repository as defined in the `repos` section in the [project environment file](#project-environment-file), and the value is the directory, relative to the project root directory, in which the repository will cloned when in development mode. |
| <nobr>`project_dir_relpath`</nobr> | Path, relative to the [controller root directory](http://github.com/lucasbasquerotto/ctl#root-directory), in which the artifacts created by this project are located. **This indicates where the project directory is located.**. |
| <nobr>`repo.env_file`</nobr> | The location of the [project environment file](#project-environment-file), inside the project environment repository. |
| <nobr>`repo.src`</nobr> | The source of the [project environment repository](#project-environment-repository). |
| <nobr>`repo.ssh_file`</nobr> | When specified (non empty), is the path in which the ssh key file to be used to clone the repository (when private) is located (the original path is relative to the [main environment repository](http://github.com/lucasbasquerotto/ctl#main-environment-repository), but at this point the original file was already copied, and possibly decrypted, to a path inside the project directory, `project_base_dir`). |
| <nobr>`repo.version`</nobr> | The version (branch/tag) of the [project environment repository](#project-environment-repository). |
| <nobr>`repo_vault.file`</nobr> | Path to the vault file with the pass to decrypt the project encrypted values. |
| <nobr>`repo_vault.force`</nobr> | Boolean (or string equivalent) to specify if the vault pass will be prompted if a vault file is not specified (when there isn't a vault file (`repo_vault.file` is empty), and `repo_vault.force` is `false`, the project mustn't have encrypted values, or an error will be thrown, when trying to decrypt them). |

## Cloud Preparation Step

This step receives a `project-dir` parameter with the [project base directory](#project-base-directory), then use the [Cloud Input Vars](#cloud-input-vars) at `<project_base_dir>/files/ctl/vars.yml` to load the [Project Environment](#project-environment), and, finally, for each context defined in the input vars (`ctxs`), clone the cloud repository for that context, as well as the repositories that will act as extensions (`env_repos`) for the cloud repository for the given context.

This preparation step is commonly executted inside a container, runs only once for the project and is the same even if the cloud repositories for the contexts are different, so it's expected that all the contexts in a project are compatible with this preparation step, and any specific stuff related to the context is run in the [Cloud Context Preparation Step](#cloud-context-preparation-step).

When loading the environment variables defined in the [`env_file`](#project-environment-file), if `repo_vault.file` is defined, the vault file there is used to [decrypt the encrypted values](#encrypt-and-decrypt). The [`env_file`](#project-environment-file) can access use jinja2 expressions and has access to the following variables:

- `project_name` (`string`): the project name, the value of `key` in the [Cloud Input Vars](#cloud-input-vars).
- `project_ctxs` (`list` of `string`): the contexts that will run in the project, the value of `ctxs` in the [Cloud Input Vars](#cloud-input-vars). The value `ctxs` is optional in the [Cloud Input Vars](#cloud-input-vars), and if not defined there, should be defined in the `env_file` (or `env_base_file`)
- `params` (`dict`): any parameters defined at `env_params` in the [Cloud Input Vars](#cloud-input-vars).

Aside from `project-dir`, the file that [runs this preparation step](container/run.sh) also accepts the following options:

| Option        | Description |
| ------------- | ----------- |
| <nobr>`-f`</nobr><br><nobr>`--force`</nobr> | Force the execution even if the commit of the [project environment repository](#project-environment) is the same as the last time it was executed. |
| <nobr>`-n`</nobr><br><nobr>`--next`</nobr> | The deployment will use parameters passed after the project name to be used by the next steps. The parameters are specified at the [Cloud Next Parameters](#cloud-next-parameters) section._ |
| <nobr>`-p`</nobr><br><nobr>`--prepare`</nobr> | Only runs the [Cloud Preparation Step](#cloud-preparation-step) and [Cloud Context Preparation Step](#cloud-context-preparation-step).<br><br>This has a particular feature that allows to pass arguments to each step that will handle it (as long as subsequent layers handle it). For example, passing the args `-vv` would generally be used only by the last step ([Cloud Context Main Step](#cloud-context-main-step)), but in this case it will be used as args to run the [Cloud Preparation Step](#cloud-preparation-step) and no args to subsequent steps.<br><br>You can pass `--` to indicate the end of the arguments for a given step, so the following args `-a -b -c -- -d` will pass the argument `-a -b -c` to the [Cloud Preparation Step](#cloud-preparation-step), and `-d` to the [Cloud Context Preparation Step](#cloud-context-preparation-step). You can use `--skip` to skip a given step (you shouldn't pass `--` in this case). For example, `--skip -c -d` will skip the [Cloud Preparation Step](#cloud-preparation-step) and pass `-c -d` to the [Cloud Context Preparation Step](#cloud-context-preparation-step). |
| <nobr>`-s`</nobr><br><nobr>`--fast`</nobr> | Skips the [Cloud Preparation Step](#cloud-preparation-step) and [Cloud Context Preparation Step](#cloud-context-preparation-step). |
| <nobr>`--debug`</nobr> | Runs in verbose mode and forwards this option to the subsequent step. |

In this step, when the `dev` input var is `true`, the `path_params` value in the [Cloud Input Vars](#cloud-input-vars) file will be included in a new file at `<project_base_dir>/files/cloud/path-map.yml` so that the next steps can use it to map repositories to other locations and skip pulling already cloned repositories.

The value of `env_params` is written to the file `<project_base_dir>/files/cloud/env-params.yml` so that the next steps can use it to load the [`env_file`](#project-environment-file).

For each context in the project, 2 files with the same content in a different format will be created at `<project_base_dir>/files/cloud/ctxs/<ctx>/vars.yml` and `<project_base_dir>/files/cloud/ctxs/<ctx>/vars.sh` to be used in the [Cloud Context Preparation Step](#cloud-context-preparation-step) and [Cloud Context Main Step](#cloud-context-main-step). The contents of those files are defined in the [Cloud Context Input Vars](#cloud-context-input-vars) section.

This steps generate a file `<project_base_dir>/files/cloud/run-ctxs` to run each context passing as the first parameter the location of context directory (`<project_base_dir>/files/cloud/ctxs/<ctx>/`). Each context is run entirely ([Cloud Context Preparation Step](#cloud-context-preparation-step) and [Cloud Context Main Step](#cloud-context-main-step)) before starting the next context.

## Cloud Context Input Vars

These are the input variables used by the [Cloud Context Preparation Step](#cloud-context-preparation-step) and [Cloud Context Main Step](#cloud-context-main-step). They are generated by the [Cloud Preparation Step](#cloud-preparation-step). There are 2 files generated with the same content, but in a different format:

_`<project_base_dir>/files/cloud/ctxs/<ctx>/vars.sh`_

```shell
export commit=24c74d6130bc3602388769aad14cbca8092a20b5
export ctx=demo
export ctx_dev_dir=/main/dev/link/projects/demo/files/cloud/ctxs/demo
export ctx_dir=/main/files/cloud/ctxs/demo
export dev_repos_dir=/main/dev/link
export env_dev=true
export env_dir=/main/dev/link/repos/env
export env_file=/main/dev/link/repos/env/common/demo.yml
export env_lax=true
export env_params_file=/main/files/cloud/env-params.yml
export path_map_file=/main/files/cloud/path-map.yml
export project=demo
export repo_dir=/main/files/cloud/ctxs/demo/repo
export repo_run_file=/main/files/cloud/ctxs/demo/repo/run
export secrets_cloud_dir=/main/secrets/cloud
export secrets_ctx_dir=/main/secrets/cloud/ctxs/demo
export vault_file=/main/secrets/ctl/vault
```

_`<project_base_dir>/files/cloud/ctxs/<ctx>/vars.yml`_

```yaml
commit: 24c74d6130bc3602388769aad14cbca8092a20b5
ctx: demo
ctx_dev_dir: /main/dev/link/projects/demo/files/cloud/ctxs/demo
ctx_dir: /main/files/cloud/ctxs/demo
dev_repos_dir: /main/dev/link
env_dev: 'true'
env_dir: /main/dev/link/repos/env
env_file: /main/dev/link/repos/env/common/demo.yml
env_lax: 'true'
env_params_file: /main/files/cloud/env-params.yml
path_map_file: /main/files/cloud/path-map.yml
project: demo
repo_dir: /main/files/cloud/ctxs/demo/repo
repo_run_file: /main/files/cloud/ctxs/demo/repo/run
secrets_cloud_dir: /main/secrets/cloud
secrets_ctx_dir: /main/secrets/cloud/ctxs/demo
vault_file: /main/secrets/ctl/vault
```

| Option | Description |
| ------ | ----------- |
| <nobr>`commit`</nobr> | The commit of the [project environment repository](#project-environment). |
| <nobr>`ctx`</nobr> | The environment context to be used in this step. |
| <nobr>`ctx_dev_dir`</nobr> | The context directory path inside the container using the path after `dev_repos_dir` when in development mode (mainly used to determine the relative paths between mapped repositories (`path_map_file`) and files and directories inside the context directory, `ctx_dir`). |
| <nobr>`ctx_dir`</nobr> | The context directory path inside the container. |
| <nobr>`dev_repos_dir`</nobr> | Path, inside the container, of the [controller root directory](http://github.com/lucasbasquerotto/ctl#root-directory) when in development mode. |
| <nobr>`env_dev`</nobr> | Boolean (or string equivalent) to specify if the project will run in development mode. |
| <nobr>`env_dir`</nobr> | The environment repository directory path inside the container. |
| <nobr>`env_file`</nobr> | The full path of the [project environment file](#project-environment-file), inside the container. |
| <nobr>`env_lax`</nobr> | Indicates if files and directories created and copied during the deployment will have less strict permissions (when `true`; recommended when in development). |
| <nobr>`env_params_file`</nobr> | Path, inside the container, of the `yaml` file that will have the value of `env_params` defined in the [Cloud Input Vars](#cloud-input-vars). |
| <nobr>`path_map_file`</nobr> | Path, inside the container, of the `yaml` file that will have the value of `path_params.path_map_repos` defined in the [Cloud Input Vars](#cloud-input-vars). |
| <nobr>`project`</nobr> | The project identifier, that has the value of `key` defined in the [Cloud Input Vars](#cloud-input-vars). |
| <nobr>`repo_dir`</nobr> | The cloud repository directory path inside the container. |
| <nobr>`repo_run_file`</nobr> | The file, inside the container, to run the cloud context steps ([Cloud Context Preparation Step](#cloud-context-preparation-step) and [Cloud Context Main Step](#cloud-context-main-step)).  |
| <nobr>`secrets_cloud_dir`</nobr> | The path, inside the container, of the directories with the secrets of the cloud layer. |
| <nobr>`secrets_ctx_dir`</nobr> | The path, inside the container, of the directories with the secrets of the current context in the cloud layer. |
| <nobr>`vault_file`</nobr> | Path, inside the container, to the vault file with the pass to decrypt the project encrypted values. |

The values of the files above are the output after running the [Cloud Preparation Step](#cloud-preparation-step) with the input variables in the [example](#cloud-input-vars) above.

## Cloud Context Preparation Step

This step as [defined in this repository](prepare.ctx.yml) does the following tasks:

1. Loads (from the environment repository) and validates the environment (`env`) variable [schema](#schemas) (as defined in the corresponding [schema file](schemas/env.schema.yml)).

2. Prepare the repositories defined in the `extra_repos` defined for the context in the environment file (`main.<ctx>.extra_repos`), which could be used, for example, to setup all the required repositories of a development environment to setup the workspace. It also clones the repositories of the pods defined for the nodes of the context (used when transfering templates of the pod to the actual pod repository in remote hosts, because Ansible requires that templates should be in the local machine, as well as some validations). This step doen't run when the `--prepare` and `--fast` flags are specified.

3. Defines and validates the context (`ctx_data`) variable, [merging and overriding parameters](#mergeable-parameters), defining the context ansible fact to be used for the next steps, so that those steps don't need to do it again. Validates [schemas](#schemas) for services, nodes, tasks and pods, and do several other types of validations, like ensuring the existence of some files that will be transfered.

4. Creates the hosts file to be used by Ansible when connecting to hosts (when new hosts are created dynamically, this file is updated) as well as the (optional) configuration file (`ansible.cfg`), that by default is the file [ansible/ansible.cfg](ansible/ansible.cfg), but can be overridden using the `cfg` property in the context object (in the environment file):

```yaml
# ...
main:
  my_context:
    repo: "cloud"
    cfg: |
      [defaults]
      interpreter_python=/usr/bin/python3
      stdout_callback = default
      collections_paths = collections
    hosts: |
      [main]
      localhost ansible_connection=local
      [host]
    # ...
  # ...
# ...
```

5. Creates the playbook to execute instructions in the hosts (from `files/run.tpl.yml` to `plays/run.yml`). This is needed because the instructions, and hosts to run the instructions, as well the order in which they are run, are dynamically defined in the project environment file, but Ansible expects that the playbook is already created and the hosts and plays to be statically defined when it starts to run the [Cloud Context Main Step](#cloud-context-main-step).

## Cloud Context Main Step

TODO

# Project Environment

The project environment is defined loading the [`env_file`](#project-environment-file) together with the params passed to it by the [Cloud Preparation Step](#cloud-preparation-step) (`project_name`, `project_ctxs` and `params`).

If the file has a top-level variable `env`, it will load the [`env_base_file`](#project-environment-base-file) passing the variables loaded from the [`env_file`](#project-environment-file) as params.

The loaded result from these files can be refered as being the **Project Environment**.

## Project Environment File

The project environment is defined loading the file defined in the variable `env_file` from the [Cloud Input Vars](#cloud-input-vars) together with the params passed to it by the [Cloud Preparation Step](#cloud-preparation-step) (`project_name`, `project_ctxs` and `params`).

This file should be inside the **project environment repository**, which should be cloned from `repo.src` with in the branch/tag `repo.version` specified in the [Cloud Input Vars](#cloud-input-vars). If `repo.ssh_file` is specified, the ssh file defined at `<project_base_dir>/secrets/ctl/` is used.

**Depending on the context, the project environment file may refer to the [Project Environment](#project-environment) itself.**

## Project Environment Base File

If the [`env_file`](#project-environment-file) has a top-level variable `env`, it will clone/pull the **project environment base repository** defined at `env.repo` in the directory `env.repo_dir` inside the project environment directory, then load the [`env_base_file`](#project-environment-base-file) defined at `env.file` relative to the project environment base repository, passing the variables loaded from the [`env_file`](#project-environment-file) as params.

It's not required for an [`env_file`](#project-environment-file) to have `env` specified in it to load variables from a base repository, but **this is very useful to share deployment variables between different environments (like staging and production)**, while keeping environment specific stuff, like endpoints, tokens, secrets, and other types of credentials in a separate directory.

_Example of an `env_file` that loads another file from a base repository:_

```yaml
name: "{{ project_name }}"
ctxs: "{{ project_ctxs }}"
env:
  repo:
    src: "https://github.com/lucasbasquerotto/project-env-base-demo.git"
    version: "master"
  repo_dir: "env-base"
  file: "common/repos.yml"
```

# Useful Information

## Cloud Next Parameters

The following are the parameters that can be specified when deploying a project, specific to this layer:

| Option | Description |
| ------ | ------- |
| <nobr>`--end`</nobr> | Will destroy what was created by the deployment, the nodes and services, as long as the property `can_destroy` is defined and is `true` for them. It sends the state `absent` and expects that the nodes and services know how to handle this state. This is almost the same as running without the `--next` parameter as one of the launch parameters, and passing `--tags=destroy`, except that using `--end` won't register the commit of the project environment repository (used to skip newer deployments with the same commit, when not using the `--force` option) for this deployment (which is the expected). |
| <nobr>`--ssh`</nobr> | Will ssh into the host specified by the context (`-c`/`--ctx`), node type (`-n`/`--node`) and index (`-i`/`--idx`), these params specified right after `--ssh`. When the context is not specified, if there is only one context in the deployment, this context will be used by default, otherwise an error will be thrown. When the node type is not specified, if there is only one node type in the context, this node type will be used by default, otherwise an error will be thrown. When the index is not specified, the default will be `1` (the first host with of the before mentioned node type). This ssh option can only be used after the preparation step is completed, and the hosts are defined in the hosts file (either directly or after a node service creates them). |

## Mergeable Parameters

The environment file accepts some sections with `params`, `group_params`, `shared_params` and `shared_group_params` that can be merged and overridden. These parameters are merged in the step **#3** of the [Cloud Context Preparation Step](#cloud-context-preparation-step). **These mergeable parameters can be very useful to achieve a DRY approach, avoiding lots of duplication, but should be used moderately and with a good understanding of what it does, so as to not generate an illegible environment file with lots of indirections.**

The values specified in `params` will be considered as is.

```yaml
services:
  my_service:
    params:
      param1: 1
      param2: 2
```

_The above remains unchanged when the parameters are processed._

The values specified in `group_params` must be a dictionary in which the value of each property is a string that references a property in a group params dictionary that contains the values that will be mapped to the initial dictionary properties. The group params dictionary depends on the context that the `group_params` is specified (for example, if defined in a service, the group params dictionary is `service_group_params` defined at the topmost layer of the project environment variable; if defined in a node, will be `node_group_params`; and so on).

```yaml
services:
  my_service:
    group_params:
      param1: "group_1"
      param2: "group_2"
service_group_params:
  group_1: 3
  group_2: 4
```

_Is equivalent to:_

```yaml
services:
  my_service:
    params:
      param1: 3
      param2: 4
```

The values specified in `shared_params` must be an array of strings in which each string references a property in a shared params dictionary that contains the values that will be mapped to the whole parameter. The shared params dictionary depends on the context that the `shared_params` is specified (for example, if defined in a service, the shared params dictionary is `service_shared_params` defined at the topmost layer of the project environment variable; if defined in a node, will be `node_shared_params`; and so on).

The shared parameters are overridden in the order in which they are specified in the array, so the last one overrides all others, and the first is overridden by all others.

```yaml
services:
  my_service:
    shared_params: ["shared_1", "shared_2"]
service_shared_params:
  shared_1:
    param1: 11
    param2: 12
  shared_2:
    param2: 22
    param3: 23
```

_Is equivalent to:_

```yaml
services:
  my_service:
    params:
      param1: 11
      param2: 22
      param3: 23
```

The values specified in `shared_group_params` must be a string that references a property in a shared group params dictionary that contains the values that will expanded as group parameters, and then mapped to the whole parameter as a shared parameter. The shared group params dictionary depends on the context that the `shared_group_params` is specified (for example, if defined in a service, the shared params dictionary is `service_shared_group_params` defined at the topmost layer of the project environment variable; if defined in a node, will be `node_shared_group_params`; and so on).

The properties in the shared group params dictionary should behavle as `group_params`, so they must be dictionaries in which each property value is a string that map to the group params dictionary.

```yaml
services:
  my_service:
    shared_group_params: "shared_group_1"
service_shared_group_params:
  shared_group_1:
    param1: "group_shared_1"
    param2: "group_shared_2"
service_group_params:
  group_shared_1: 123
  group_shared_2: 456
```

_Is equivalent to:_

```yaml
services:
  my_service:
    params:
      param1: 123
      param2: 456
```

These sections are merged to result in a single parameter (`params`) property, with the precedence `shared_group_params` < `shared_params` < `group_params` < `params`, which means, for example, that what is defined in `params` will override the same parameter if specified in another section.

```yaml
services:
  my_service:
    params:
      param1: "value_1"
    group_params:
      param1: "group_1"
      param2: "group_2"
    shared_params: ["shared_1", "shared_2"]
    shared_group_params: "shared_group_1"
service_shared_group_params:
  shared_group_1:
    param1: "group_shared_1"
    param2: "group_shared_2"
    param3: "group_shared_3"
    param4: "group_shared_4"
    param5: "group_shared_5"
    param6: "group_shared_6"
service_shared_params:
  shared_1:
    param1: "value_shared_1_1"
    param2: "value_shared_1_2"
    param3: "value_shared_1_3"
    param4: "value_shared_1_4"
  shared_2:
    param4: "value_shared_2_4"
    param5: "value_shared_2_5"
service_group_params:
  group_1: "value_group_1"
  group_2: "value_group_2"
  group_shared_1: "value_group_shared_1"
  group_shared_2: "value_group_shared_2"
  group_shared_3: "value_group_shared_3"
  group_shared_4: "value_group_shared_4"
  group_shared_5: "value_group_shared_5"
  group_shared_6: "value_group_shared_6"
```

_Is equivalent to:_

```yaml
services:
  my_service:
    params:
      param1: "value_1"
      param2: "value_group_2"
      param3: "value_shared_1_3"
      param4: "value_shared_2_4"
      param5: "value_shared_2_5"
      param6: "value_group_shared_6"
```

Aside from merging the parameters defined in adjacent sections, the parameters can be overridden if the item that contains them are referenced in another place that allows to specify parameters for it. For example, when defining a list of services to be executed, instead of only the service name, mergeable parameters can also be defined for the service (as long as the service is not a list of services). The parameters defined here will have precedence over the parameters defined in the service directly:

```yaml
main:
  my_context:
    #...
    initial_services:
      - name: "my_service_01"
        key: "my_service"
        params:
          param1: "overridden_value_1_1"
        group_params:
          param1: "overridden_group_1_1"
          param2: "overridden_group_1_2"
      - name: "my_service_02"
        key: "my_service"
        params:
          param1: "overridden_value_2_1"
services:
  my_service:
    #...
    params:
      param1: "value_1"
    group_params:
      param1: "group_1"
      param2: "group_2"
service_group_params:
  group_1: "value_group_1"
  group_2: "value_group_2"
  overridden_group_1_1: "overridden_value_group_1_1"
  overridden_group_1_2: "overridden_value_group_1_2"
```

_Is equivalent to:_

```yaml
main:
  my_context:
    #...
    initial_services:
      - name: "my_service_01"
        key: "my_service"
        params:
          param1: "overridden_value_1_1"
          param2: "overridden_value_group_1_2"
      - name: "my_service_02"
        key: "my_service"
        params:
          param1: "overridden_value_2_1"
services:
  my_service:
    #...
    params:
      param1: "value_1"
      param2: "value_group_2"
```

_Which is also equivalent to:_

```yaml
main:
  my_context:
    #...
    initial_services: ["my_service_01", "my_service_02"]
services:
  my_service_01:
    #...
    params:
      param1: "overridden_value_1_1"
      param2: "overridden_value_group_1_2"
  my_service_02:
    #...
    params:
      param1: "overridden_value_2_1"
      param2: "value_group_2"
```

## Credentials

In general, credentials are used similarly to `group_params` as described at [mergeable parameters](#mergeable-parameters), in which you define a dictionary in which the value of each property is mapped to the property in the `credentials` section with that name. Like the mergeable parameters, they are mapped in the step **#3** of the [Cloud Context Preparation Step](#cloud-context-preparation-step).

_For example:_

```yaml
services:
  my_service:
    #...
    credentials:
      secret_01: "credential_01"
      secret_02: "credential_02"
credentials:
  credential_01:
    credential_01_param_01: "secret_value_01_01"
    credential_01_param_02: "secret_value_01_02"
  credential_02:
    credential_02_param_01: "secret_value_02_01"
    credential_02_param_02: "secret_value_02_02"
```

_Will turn into:_

```yaml
services:
  my_service:
    #...
    credentials:
      secret_01:
        credential_01_param_01: "secret_value_01_01"
        credential_01_param_02: "secret_value_01_02"
      secret_02:
        credential_02_param_01: "secret_value_02_01"
        credential_02_param_02: "secret_value_02_02"
```

One exception is the `nodes` section, in which it's not a dictionary `credentials` but a single `credential` string property that is mapped to a credentials in the `credentials` section:

```yaml
nodes:
  my_node:
    #...
    credential: "my_credential"
credentials:
  my_credential:
    credential_01: "secret_value_01"
    credential_02: "secret_value_02"
```

_Will turn into:_

```yaml
nodes:
  my_node:
    #...
    credential:
      credential_01: "secret_value_01"
      credential_02: "secret_value_02"
```

## Contents

When referring to `contents` here, the most common meaning is a string that can be huge, commonly stored in files, that can also be processed as templates (with jinja2), according to the parameters and credentials specified, as well as other internal contents that can be specified.

### Content Type

A content may be specified in different ways. It can be a string (`str`), a file, a (file) template or come from the `contents` section in the environment file, using the type `env`, and identifying with the `key` property (or the `name` property, if the `key` property is not specified).

_For example:_

Considering the following files:

_path/to/content/file.txt:_

```
I'm a content
This is a new line
```

_path/to/content/template.txt:_

```
I'm a {{ params.who_am_i }
This is a new line
```

Then the following cases are the same, only specified in different ways:

_Case 01:_

```yaml
services:
  my_service:
    #...
    contents:
      my_content:
        type: "str"
        params:
          value: |
            I'm a content
            This is a new line
```

_Case 02:_

```yaml
services:
  my_service:
    #...
    contents:
      my_content: |
        I'm a content
        This is a new line
```

(This is a short version of the previous case. When the type of the content is a string, it considers its type as `str`, and `params.value` as the string value.)

_Case 03:_

```yaml
services:
  my_service:
    #...
    contents:
      my_content:
        file: "path/to/content/file.txt"
```

(When the type of the content is a dictionary, it considers its type as `file`)

_Case 04:_

```yaml
services:
  my_service:
    #...
    contents:
      my_content:
        type: "template"
        file: "path/to/content/template.txt"
        params:
          who_am_i: "content"
```

_Case 05:_

```yaml
services:
  my_service:
    #...
    contents:
      my_content:
        name: "my_env_content"
        type: "env"
contents:
  my_env_content: |
    I'm a content
    This is a new line
```

### Content Origin

The contents may come from different places, when its type is `file` or `template`, according to the origin specified (`custom`, `env` or `cloud`).

- When `origin` is `env`, the file path is relative to the [project environment repository](#project-environment).
- When `origin` is `cloud`, the file path is relative to the cloud repository (specified in the main/context section, in the `repo` property).
- When `origin` is `custom` (default), the file path is relative do a path that depends on where it is used. For example, if specified in a pod, it will be relative to the pod repository; if specified in an [extra_repo](#cloud-context-preparation-step), it will be relative to that repository. When there isn't a specific path to be used, it's equivalent to `cloud` (for example, when used in a service or in a task at [run_stages](run-stages)).

### Content Full Example

Considering that the [project environment repository](#project-environment) has the following files:

_path/to/content/file.txt:_

```
I'm a file content
This is a new line
```

_path/to/content/template.txt:_

```
I'm a template content
This is a new line

Value of params.param_01: {{ params.param_01 }}
Value of params.param_02: {{ params.param_02 }}

Value of credentials.secret_01: {{ credentials.secret_01 }}
Value of credentials.secret_02: {{ credentials.secret_02 }}

Value of contents.inner_content_01:
-----------------------------------
{{ contents.inner_content_01 }}
-----------------------------------

Value of contents.inner_content_02:
-----------------------------------
{{ contents.inner_content_02 }}
-----------------------------------
```

_path/to/content/template.inner.txt:_

```
I'm a template content inside another template content
This is a new line
Value of params.param_01: {{ params.param_01 }}
Value of params.param_02: {{ params.param_02 }}
```

Then the following:

```yaml
services:
  my_service:
    #...
    contents:
      content_str: |
        I'm a string content
        This is a new line
      content_file:
        origin: "env"
        file: "path/to/content/file.txt"
      content_template:
        type: "template"
        origin: "env"
        file: "path/to/content/template.txt"
        credentials:
          secret_01: "credential_01"
          secret_02: "credential_02"
        params:
          param_01: "value_01"
        group_params:
          param_01: "group_01"
          param_02: "group_02"
        contents:
          inner_content_01: "I'm a small string"
          inner_content_02:
            name: "my_inner_content_02"
            key: "my_content"
            type: "env"
            params:
              param_01: "overridden_value_01"
contents:
  my_content:
    content_template:
      type: "template"
      origin: "env"
      file: "path/to/content/template.inner.txt"
      params:
        param_01: "value_01"
        param_02: "value_02"
content_group_params:
  group_01: "value_group_01"
  group_02: "value_group_02"
credentials:
  credential_01: "secret_value_01"
  credential_02: "secret_value_02"
```

(You can see about `group_params` and overridable parameters in the section about [mergeable parameters](#mergeable-parameters).)

_Is equivalent to:_

```yaml
services:
  my_service:
    #...
    contents:
      content_str: |
        I'm a string content
        This is a new line
      content_file:
        origin: "env"
        file: "path/to/content/file.txt"
      content_template:
        type: "template"
        origin: "env"
        file: "path/to/content/template.txt"
        credentials:
          secret_01: "credential_01"
          secret_02: "credential_02"
        params:
          param_01: "value_01"
          param_02: "value_group_02"
        contents:
          inner_content_01: "I'm a small string"
          inner_content_02: |
            I'm a template content inside another template content
            This is a new line
            Value of params.param_01: overridden_value_01
            Value of params.param_02: value_02
credentials:
  credential_01: "secret_value_01"
  credential_02: "secret_value_02"
```

_Which is also equivalent to:_

```yaml
services:
  my_service:
    #...
    contents:
      content_str: |
        I'm a string content
        This is a new line
      content_file: |
        I'm a file content
        This is a new line
      content_template: |
        I'm a template content
        This is a new line

        Value of params.param_01: value_01
        Value of params.param_02: value_group_02

        Value of credentials.secret_01: secret_value_01
        Value of credentials.secret_02: secret_value_02

        Value of contents.inner_content_01:
        -----------------------------------
        I'm a small string
        -----------------------------------

        Value of contents.inner_content_02:
        -----------------------------------
        I'm a template content inside another template content
        This is a new line
        Value of params.param_01: overridden_value_01
        Value of params.param_02: value_02
        -----------------------------------
```

And can be accessed in the service task as `inner_service_contents.content_str`, `inner_service_contents.content_file` and `inner_service_contents.content_template`.

## Schemas

Schemas are defined to validate the structure of data that will be used in a given context. Most schema validations are done in the preparation steps ([Cloud Preparation Step](#cloud-preparation-step) and [Cloud Context Preparation Step](#cloud-context-preparation-step), specially in the later).

In most cases, schemas validate user defined data generated from [mergeable parameters](#mergeable-parameters), [credentials](#credentials), [contents](#contents), or a combination of them.

For example, if you try to specify `test: "my value"` in the top-most layer of the project environment file, you will receive an error saying that the property `test` is invalid, because the environment variable will be validated using the schema defined at [schemas/env.schema.yml](schemas/env.schema.yml).

The schema that validates the environment variable as a whole is fixed, but you can define custom schemas for specific cases, like services (when the service is not a list of services) and contents (when `type` is `template`). In the enviroment file, custom schemas are normally defined specifying the path to a custom schema file in a place that accepts a schema. Custom schemas are very useful because there are validations that depends on the environment, so they can't be known beforehand by the cloud layer.

_For example:_

Consider the following schema file:

_my/schema.yml_

```yaml
root: "my_schema"
schemas:
  my_schema:
    type: "dict"
    props:
      params:
        schema: "params"
        non_empty: true
  params:
    type: "dict"
    props:
      prop1:
        type: "str"
        non_empty: true
```

Then the following specification in the environment file:

```yaml
#...
main:
  my_context:
    #...
    initial_services:
      - "my_service_01"
      - "my_service_02"
      - "my_service_03"
      - "my_service_04"
      - "my_service_05"
      - "my_service_06"
services:
  my_service_01:
    #...
    schema: "my/schema.yml"
    params:
      prop1: "some value 01"
  my_service_02:
    #...
    schema: "my/schema.yml"
    params:
      prop1: "some value 01 - 02"
      prop2: "some value 02 - 02"
  my_service_03:
    #...
    schema: "my/schema.yml"
  my_service_04:
    #...
    schema: "my/schema.yml"
    params:
      prop1: ""
  my_service_05:
    #...
    schema: "my/schema.yml"
    params:
      prop1: "some value 05"
    contents:
      my_content: "content value"
  my_service_06:
    #...
    params:
      prop1: "some value 05"
    contents:
      my_content: "content value"
#...
```

Will have the following validation result:

- ✔️ The service `my_service_01` is validated successfully.
- ❌ The service `my_service_02` is validated unsuccessfully: `params.prop2` is present in the value being validated, but not specified in the schema.
- ❌ The service `my_service_03` is validated unsuccessfully: `params` is not present in the value being validated, but is required (`non_empty`) by the schema.
- ❌ The service `my_service_04` is validated unsuccessfully: `params.prop1` is empty in the value being validated, but the schema requires it to not be empty (`non_empty`).
- ❌ The service `my_service_05` is validated unsuccessfully: `contents` is present in the value being validated, but in the schema only `params` is present (when validating a service, for example, it is passed an object with its `params`, `credentials` and `contents`, but only when they are specified).
- ⚠️ The service `my_service_06` is not validated (it's advisable to validate with a custom schema in this case, although it's not required).

**Important:** Only sections used by the context are validated, so if `initial_services` was `["my_service_01", "my_service_06"]`, and the other services weren't used anywhere else in the context, there would be no errors.

Before validating the value, the schema itself is validated (because the schema may be wrong, for example, due to a typo). To validate the schemas, the schema at [schemas/schema.yml](schemas/schema.yml) is used. **You can take a look at it to familiarize yourself with schemas, as well as know what can be defined in a schema and their meanings.**

## Extra Repositories

The notation **extra repositories** is used to reference source control repositories that are cloned locally, defined in the `extra_repos` context property (in the main section).

One useful way to use them is to prepare a development environment, creating a project that maps the repositories that will be used in that environment to the paths in which you want them to be mapped.

_Here is a full example of an environment file:_

```yaml
name: "{{ params.name | default('repos') }}"
ctxs: ["repos_ctx"]
container: ""
main:
  repos_ctx:
    repo: "cloud"
    hosts: |
      [main]
      localhost ansible_connection=local
      [host]
    extra_repos:
      - repo: "env_base"
        dir: "env-base"
      - repo: "custom_cloud"
        dir: "custom-cloud"
      - repo: "pod"
        dir: "pod"
      - repo: "custom_pod"
        dir: "custom-pod"
      - repo: "app"
        dir: "app"
      - repo: "container_images"
        dir: "container-images"
      - repo: "backups"
        dir: "backups"
repos:
  env_base:
    src: "https://github.com/lucasbasquerotto/env-base.git"
    version: "master"
  cloud:
    src: "https://github.com/lucasbasquerotto/cloud.git"
    version: "master"
  custom_cloud:
    src: "https://github.com/lucasbasquerotto/custom-cloud.git"
    version: "master"
  pod:
    src: "https://github.com/lucasbasquerotto/pod.git"
    version: "master"
  custom_pod:
    src: "https://github.com/lucasbasquerotto/custom-pod.git"
    version: "master"
  app:
    src: "https://github.com/lucasbasquerotto/wordpress-docker.git"
    version: "master"
  container_images:
    src: "https://github.com/lucasbasquerotto/container-images.git"
    version: "master"
  backups:
    src: "https://github.com/lucasbasquerotto/backups.git"
    version: "master"
```

Then, in the `vars.yml` file in the main environment repository, add the project:

#TODO add repos project definition

And run in development mode:

```shell
./ctl/launch -df repos
```

After that, the repositories specified in the `repos` section in the project environment file will be cloned in the paths specified in the `vars.yml` file (if some extra repository is not mapped in the `vars.yml` file, or if the project is deployed without the `-d`/`--dev` option, the repositories would be cloned in the directory for extra repositories for the project context, more specifically at `projects/repos/files/cloud/ctxs/repos_ctx/extra-repos/<extra_repo_dir>` in the controller root directory).

Another use case for extra repositories is to reference repositories of the app layer in the pod layer when developing locally, so that you can map it to a pod container as a volume and execute a service with live changes, changing the code in the app repository, and seeing the changes without having to generate a new image.

_Sample (extra repos with app directory and docker-compose):_

_Project Environment File:_

```yaml
#...
main:
  my_context:
    #...
    extra_repos:
      - repo: "app_dir"
        dir: "app-dir"
pods:
  my_pod:
    repo: "pod"
    ctx: "path/to/ctx.yml"
    fast_prepare: true
    params:
      app_dir: "app-dir"
```

_path/to/ctx.yml (in the pod repository):_

```yaml
{% set var_app_repo_dir = params.extra_repos_dir_relpath + '/' + params.main.app_dir %}

templates:

- src: "templates/docker-compose.env"
  dest: ".env"
  params:
    app_repo_dir: "{{ var_app_repo_dir }}"
```

(the parameter `extra_repos_dir_relpath` is always sent to the pod context)

_templates/docker-compose.env (in the pod repository):_

```yaml
APP_REPO_DIR={{ params.app_repo_dir }}
```

_docker-compose.yml (excerpt, in the pod repository):_

```yaml
services:
  my_service:
    image: "my_image"
    volumes:
      - "$APP_REPO_DIR:/path/inside/container"
```

## Run Stages

#TODO

## Encrypt and Decrypt

To encrypt and decrypt values and files, use `ansible-vault` as defined at http://github.com/lucasbasquerotto/ctl#encrypt-and-decrypt.
